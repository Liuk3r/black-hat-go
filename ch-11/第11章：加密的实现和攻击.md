没有密码学的安全交流是不完整的。当组织使用加密方法时，它们可以帮助保护其信息和系统的完整性，机密性和真实性。作为工具开发人员，可能需要实现加密功能，可能用于 **SSL/TLS** 通信，相互身份验证，对称密钥加密或密码哈希。但是开发人员通常不安全地实现加密功能，这意味着有攻击意识的人可以利用这些弱点来破坏敏感的，有价值的数据，例如社保或信用卡号。

本章演示了Go中加密的各种实现，并讨论可以利用的常见弱点。虽然我们介绍不同的密码函数和代码块，但我们不探索密码算法或数学原理的细微差别。坦率地说，这远远超出了我们对密码学的兴趣（或知识）。如前所述，在未经所有者明确许可的情况下，请勿在本章中对资源或资产做任何事情。我们研究这些是出于学习目的，而不是为了协助进行非法活动。

## 回顾密码学的基本概念

在探讨Go语言中的加密之前，让我们复习一些基本的加密概念。长话短说吧。

首先，加密（出于维护机密性的目的）只是加密的任务之一。*Encryption*，通常来说是双向的，可以对数据加密，然后解密恢复初始的输入。加密数据的过程使得它在被解密之前毫无意义。

加密和解密都涉及到将数据和附带的密钥传递到加密函数。该函数输出加密的数据（称为密文）或原始的可读数据（称为明文）。有多种算法实现。`Symmetric` 算法在加解密时使用相同的秘钥，而 `asymmetric` 使用不同的秘钥。您可能会使用加密来保护传输中的数据或存储敏感信息（例如信用卡号），以便日后解密，这可能是为了方便将来的购买或欺骗监控。 

另一方面，`hashing`是用于对数据进行数学扰乱的单向过程。可以将敏感信息传递到哈希函数来生成固定长度的输出。当使用强大的算法（例如SHA-2系列算法）时，不同输入产生相同输出的可能性非常低。即，发生碰撞的可能性低。由于哈希是不可逆的，因此通常用作在数据库中存储明文密码或执行完整性校验以确定数据是否被更改过。如果需要模糊或随机化两个相同输入的输出，可以使用 `salt`，这是一个随机值，用于在哈希过程中区分两个相同的输入。`salt` 通常用于密码存储，因为允许同时使用相同密码的多个用户仍然生成不同的哈希值。

密码学还提供了对消息进行身份验证的方法。`message authentication code (MAC)` 是由一个特殊的单向加密函数产生的输出。这个函数使用数据本身、一个密钥和一个初始化向量，并生成一个不太可能发生冲突的输出。消息的发送者执行生成MAC的功能，然后将MAC作为消息的一部分。接收方在本地计算MAC并将其与接收到的MAC进行比较。匹配成功表明发送方拥有正确的密钥（即发送方是可信的），并且消息没有被更改（即保持了完整性）。

现在到这，应该对密码学有足够的了解了，可以理解本章的内容。必要时，我们将讨论与给定主题相关的更多细节。先从Go的标准加密库开始吧。

## 搞懂标准加密库

在Go中实现加密的妙处在于，使用的大多数加密功能都来自于标准库。其他语言通常依赖于OpenSSL或其他第三方库，而Go的加密功能是官方库的一部分。这使得加密的实现相对简单，因为不必安装会污染开发环境的笨重的依赖项。有两个独立的库。

标准库的`crypto`包中有各种常见的加密和算法相关的子包。例如，可以使用 `aes`，`des`和`rc4`子包来实现对称密钥算法。用于非对称加密的有`dsa`和`rsa`子包；以及用于哈希的`md5`，`sha1`，`sha256`和`sha512`子包。这不是全部；另外还有用于其他加密的子包。

除了标准的 `crypto` 包，Go还有一个官方的扩展包，包含各种加密功能：`golang.org/x/crypto`。功能包括其他哈希算法，加密算法和通用功能。例如，该包中有用于*bcrypt hashing*的`bcrypt`子包（一种用于哈希密码和敏感数据的更好，更安全的替代方法），用于生成合法证书的`acme/autocert` 以及方便SSH协议通信的SSH子包。

内置`crypto`包和补充的`golang.org/x/crypto`包之间唯一真正的区别是，`crypto`包遵循更严格的兼容性要求。另外，要使用`golang .org/x/crypto`中的子包，则首先需要输入以下内容来安装该软件包：

```sh
$ go get -u golang.org/x/crypto/bcrypt
```

Go官方的 `crypto`包中所有功能和子包的完整列表，请参阅 `https://golang.org/pkg/crypto/` 和 `https://godoc.org/golang.org/x/crypto/`。

下一节将深入探讨各种加密实现。将会展示如何使用Go的加密功能来做一些邪恶的事情，例如破解密码哈希，使用静态密钥解密敏感数据以及暴力破解弱加密密码。还将使用该功能来创建使用TLS来保护传输中的通信，检查数据的完整性和真实性以及执行相互身份验证的工具。

## 探索哈希

如前所述，哈希是一种单向函数，用于根据变长输入生成固定长度、概率唯一的输出。不能反向哈希值来恢复原始输入数据。哈希通常用于存储原始明文数据，以后不再处理或验证数据的完整性。例如，糟糕的做法是存储明文密码；相反，应该存储哈希（最好是加点佐料，即随机值，以确保重复值之间的随机性）。

通过两个例子来演示Go中的哈希。第一个例子是尝试使用离线字典来破解给定的MD5或SHA-512哈希。第二个例子是演示 `bcrypt` 的实现。如前所述，`bcrypt` 是一种用于哈希敏感数据（例如密码）的更安全的算法。该算法还有降低其速度的功能，这使得破解密码更加困难。

### 破解MD5或SHA-512哈希

清单11-1是哈希破解代码。（`/`根目录中的所有代码都在github 仓库 `https://github.com/blackhat-go/bhg/` 中。）由于哈希不是可逆的，因此代码会尝试通过生成常见单词（从单词列表中提取）的哈希，然后将生成的哈希值与当前的哈希进行比较，来猜测哈希的明文。如果两个哈希值匹配，则可能就猜到了明文值。

```go
var md5hash = "77f62e3524cd583d698d51fa24fdff4f"
var sha256hash = "95a5e1547df73abdd4781b6c9e55f3377c15d08884b11738c2727dbd887d4ced"
func main() {
	f, err := os.Open("wordlist.txt")
    if err != nil {
		log.Fatalln(err) 
    }
	defer f.Close()
	scanner := bufio.NewScanner(f) 
    for scanner.Scan() {
		password := scanner.Text()
		hash := fmt.Sprintf("%x", md5.Sum([]byte(password))x) 
        if hash == md5hash {
			fmt.Printf("[+] Password found (MD5): %s\n", password) 
        }
		hash = fmt.Sprintf("%x", sha256.Sum256([]byte(password))) 
        if hash == sha256hash {
			fmt.Printf("[+] Password found (SHA-256): %s\n", password) 
        }
	}
	if err := scanner.Err(); err != nil { 
        log.Fatalln(err)
	} 
}
```

清单 11-1: 破解 MD5 和 SHA-256 哈希 (/ch-11/hashes/main.go)

首先定义两个保存目标哈希值的变量。一个是MD5 哈希，另一个是SHA-256 哈希。想象一下，您是在后漏洞阶段获取了这两个哈希，并试图通过运行散列算法生成它们的输入（明文密码）。通常可以通过检查哈希值的长度来确定算法。找到与目标匹配的哈希后，就知道是正确的输入了。

使用之前创建的字典文件作为输入列表。另外，谷歌一下可以帮助找到常用密码的字典文件。要检查MD5哈希，请打开字典文件并通过在文件描述符上创建 `bufio.Scanner` 逐行读取。每行是一个要检查的密码。将当前密码传递给 `md5.Sum(input [] byte)` 函数。此函数生成原生的MD5哈希值，因此可以使用 `fmt.Sprintf()` 函数和格式字符串 `％x`将其转换为十六进制字符串。毕竟，`md5hash` 变量由目标哈希的十六进制格式的字符串组成。转换该值可确保随后可以比较目标哈希值和计算得出的哈希值。如果这些哈希匹配，则程序会向stdout输出一条成功消息。

执行类似的过程来计算和比较SHA-256哈希。该实现与MD5代码非常相似。唯一真正的区别是，`sha256`包中有计算各种SHA散列长度的附加函数。与其调用 `sha256. sum()` （一个不存在的函数），不如调用 `sha256.Sum256(input []byte)` 强制使用SHA-256算法计算哈希值。就像在MD5示例中所做的一样，将原始字节转换为十六进制字符串，并比较SHA-256哈希值以查看是否有匹配项。

#### 实现 **bcrypt**

下一个示例展示了如何使用 `bcrypt` 加密和验证密码。与SHA和MD5不同，`bcrypt` 是为密码哈希设计的，与SHA或MD5系列相比，它成为程序员的更好选择。默认情况下， `bcrypt` 包含一个”佐料“，以及一个运行该算法更加耗费资源的成本因素。该成本因素控制着内部加密函数的迭代次数，从而增加了破解密码哈希所需的时间和精力。尽管仍然可以使用字典或暴力来破解密码，但是成本（时间）会显着增加，从而阻止了对时间敏感的漏洞后的破解。随着时间的推移，还可能会增加成本，以应对计算能力的提高。这使其可以适应将来的破解攻击。

清单11-2创建了一个bcrypt哈希，然后验证明文密码是否与给定的bcrypt哈希匹配。

```go
import ( 
    "log"
 	"os"
    "golang.org/x/crypto/bcrypt"
)
var storedHash = "$2a$10$Zs3ZwsjV/nF.KuvSUE.5WuwtDrK6UVXcBpQrH84V8q3Opg1yNdWLu"

func main() {
	var password string
	if len(os.Args) != 2 {
		log.Fatalln("Usage: bcrypt password") 
    }
	password = os.Args[1]
    hash, err := bcrypt.GenerateFromPassword( 
        []byte(password),
		bcrypt.DefaultCost, 
    )
    if err != nil { 
        log.Fatalln(err)
	}
	log.Printf("hash = %s\n", hash)
    err = bcrypt.CompareHashAndPassword([]byte(storedHash), []byte(password)) 
    if err != nil {
		log.Println("[!] Authentication failed")
		return 
    }
	log.Println("[+] Authentication successful")
}
```

清单 11-2: 比较 bcrypt 哈希 (/ch-11/bcrypt/main.go)

对于本书中的大多数代码示例，都省略了包的导入。在此示例中包含了它们，以明确表示正在使用补充的Go包`golang.org/x/crypto/bcrypt`，因为Go的标准包中没有 `bcrypt` 相关功能。然后，初始化变量 `storedHash`，该变量包含一个预先计算的，`bcrypt` 编码的哈希。这是为了演示设计的例子;的目的，硬编码一个值，而不是将示例代码连接到数据库来获取值。例如，该变量可能表示数据库中某一行值，该行存储了前端Web程序的用户身份验证信息。

接下来，根据明文密码值生成一个经过bcrypt编码的哈希。main函数读取密码值作为命令行参数，然后继续调用两个单独的bcrypt函数。第一个函数 `bcrypt.GenerateFromPassword()`接受两个参数：一个字节切片(表示明文密码)和一个成本。在此示例中，使用包里的默认值 `bcrypt.DefaultCost` 常量，在撰写本文时，该默认值为10。该函数返回编码的哈希值和产生的任何错误。

第二个调用的bcrypt函数是` bcrypt.CompareHashAndPassword()` ， 用来进行哈希比较。它接受bcrypt编码的哈希和明文密码作为字节切片。该函数解析编码的哈希，以确定成本和随机值。然后，将这些值与明文密码值一起生成bcrypt哈希。如果生成的哈希值与从已编码的`storedHash` 值提取的哈希值匹配，则提供的密码与用于创建 `storedHash`的密码匹配。这是用于对SHA和MD5进行密码破解的方法，即通过哈希函数运行给定密码并将结果与存储的哈希进行比较。这里，不像SHA和MD5那样明确地比较生成的哈希，而是检查`bcrypt.CompareHashAndPassword()` 是否返回错误。如果有错误，则说明计算出的哈希值是正确的，因此用于计算它们的密码不匹配。

以下是两个示例程序运行。第一个是不正确密码的输出：

```sh
$ go run main.go someWrongPassword
2020/08/25 08:44:01 hash = $2a$10$YSSanGl8ye/NC7GDyLBLUO5gE/ng51l9TnaB1zTChWq5g9i09v0AC 
2020/08/25 08:44:01 [!] Authentication failed
```

第二个是正确密码的输出：

```sh
$ go run main.go someC0mpl3xP@ssw0rd
2020/08/25 08:39:29 hash = $2a$10$XfeUk.wKeEePNAfjQ1juXe8RaM/9EC1XZmqaJ8MoJB29hZRyuNxz. 
2020/08/25 08:39:29 [+] Authentication successful
```

细心的可能会注意到，身份验证成功的显示的哈希与 `storedHash` 变量硬编码的值不匹配。回想下，代码调用了两个独立的函数。`GenerateFromPassword()` 函数使用随机值生成编码的哈希。使用不同的随机值，相同的密码将产生不同结果的哈希。因此,不同。`CompareHashAndPassword()` 函数通过使用与存储的哈希相同的随机值和成本来执行哈希算法，因此生成的哈希与`storedHash`变量中的哈希相同。

## 验证消息

现在将重点转向消息验证。交换消息时，需要验证数据的完整性和远程服务的真实性，以确保数据是真实且未被篡改的。消息在传输过程中是否被未经授权的来源更改？消息是由授权方发送的，还是由别的实体伪造的?

可以使用Go的`crypto/hmac` 包解决这些问题，该包实现了*Keyed-Hash Message Authentication Code* (HMAC)标准。HMAC是一种加密算法，可让检查消息是否被篡改并验证源身份。它使用哈希函数并使用共享的密钥，只有被授权产生有效消息或数据的各方才应拥有该密钥。没有共享此秘钥的攻击者无法伪造有效的HMAC值。在某些编程语言中实现HMAC可能会有些棘手。例如，某些语言会强制逐字节手动比较接收到的哈希值和计算得出的哈希值。如果开发人员过早地逐字节比较其结果，则开发人员可能会在此过程中无意中引入时序差异。攻击者可以通过测量消息处理时间来推断出预期的HMAC。此外，开发人员有时会认为HMAC（消耗一条消息和密钥）与消息之前的密钥的哈希值相同。但是，HMAC的内部不同于纯哈希功能。通过不明确地使用HMAC，开发人员会将应用程序暴露于长度扩展攻击中，在这种攻击中，攻击者会伪造消息和有效的MAC。

对我们Gophers来说幸运的是，crypto/hmac包使安全的方式实现HMAC功能变得相当容易。来看一个实现。注意，以下程序比典型的用例简单得多，后者可能涉及某种类型的网络通信和消息传递。在大多数情况下，可以根据HTTP请求参数或通过网络传输的其他消息来计算HMAC。在清单11-3所示的示例中，省略了客户端与服务器之间的通信，只看HMAC功能。

```go
var key = []byte("some random key")
func checkMAC(message, recvMAC []byte) bool {
    mac := hmac.New(sha256.New, key)
    mac.Write(message)
	calcMAC := mac.Sum(nil)
	return hmac.Equal(calcMAC, recvMAC)
}
func main() {
	// In real implementations, we’d read the message and HMAC value from network source
	message := []byte("The red eagle flies at 10:00") 	
	mac, _ := hex.DecodeString("69d2c7b6fbbfcaeb72a3172f4662601d1f16acfb46339639ac8c10c8da64631d")
    if checkMAC(message, mac) {
		fmt.Println("EQUAL") 
    } else {
		fmt.Println("NOT EQUAL") 
    }
}
```

清单 11-3: 使用HMAC进行消息身份验证 (/ch-11/hmac/main.go)

程序首先定义要用于HMAC加密的密钥。也就在这里使用硬编码，但在实际的实现中，此密钥将受到充分保护并且是随机的。该秘钥也将在端点之间共享，意味着消息发送方和接收方使用此相同的秘钥。由于未实现完整的客户端-服务器功能，所以使用这个变量，就好像它已被充分共享一样。

接下来，定义 `checkMAC()` 函数，以消息和接收到的HMAC作为参数。消息接收者将调用此函数以检查他们接收到的MAC值是否与他们在本地计算的值匹配。首先，调用 `hmac.New()` ，实参为 `sha256.New` 和 `key`，返回 `hash.Hash` 实例。在这个例子中，`hmac.New()` 函数通过使用SHA-256算法和密钥来初始化HMAC，并将结果分配给名为mac的变量。然后，可以使用此变量来计算HMAC哈希值，就像在前面的哈希示例中所做的那样。在这里，分别调用 `mac.Write(message)` 和 `mac.Sum(nil)` 。将本地计算的HMAC结果存储在名为`calcMAC` 的变量中。

下一步是比较本地计算的HMAC值是否等于收到的HMAC值。要以一种安全的方式做到这一点，可以调用 `hmac.Equal(calcMAC, recvMAC)` 。许多开发人员倾向于通过调用 `bytes.Compare(calcMAC, recvMAC)` 来比较字节片。问题是，`bytes.Compare()` 执行字典比较，遍历并比较给定切片的每个元素，直到找到差异或到达切片的末尾。比较所需的时间将根据`bytes.Compare()`在第一个元素，最后一个元素或两者之间的某个地方是否有所不同而不同。攻击者可能会及时测量这种变化，以确定预期的HMAC值并伪造合法处理的请求。`hmac.Equal()` 函数通过几乎相同的时间的方式比较切片来解决此问题。函数在何处发现差异都无所谓，因为处理时间变化不大，不会产生明显或可察觉的形式。

`main()` 函数模拟从客户端接收消息的过程。如果确实收到了一条消息，则必须从传输中读取并解析HMAC和消息。由于这只是一个模拟，因此可以对接收到的消息和接收到的HMAC进行硬编码，然后对HMAC十六进制字符串进行解码，以便将其转换成 `[]byte`。可以使用if语句来调用 `checkMAC()`函数，并将接收到的消息和HMAC传递给该函数。如前所述，`checkMAC() 函数通过使用接收到的消息和共享密钥来计算HMAC，并返回布尔值来确定接收到的HMAC和计算出的HMAC是否匹配。

尽管HMAC确实提供了真实性和完整性保证，但它不能确保私密性。无法确定是否未经授权的源看不到该消息。下一部分将通过探索和实现各种类型的加密来解决此问题。