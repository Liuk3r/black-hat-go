没有密码学的安全交流是不完整的。当组织使用加密方法时，它们可以帮助保护其信息和系统的完整性，机密性和真实性。作为工具开发人员，可能需要实现加密功能，可能用于 **SSL/TLS** 通信，相互身份验证，对称密钥加密或密码哈希。但是开发人员通常不安全地实现加密功能，这意味着有攻击意识的人可以利用这些弱点来破坏敏感的，有价值的数据，例如社保或信用卡号。

本章演示了Go中加密的各种实现，并讨论可以利用的常见弱点。虽然我们介绍不同的密码函数和代码块，但我们不探索密码算法或数学原理的细微差别。坦率地说，这远远超出了我们对密码学的兴趣（或知识）。如前所述，在未经所有者明确许可的情况下，请勿在本章中对资源或资产做任何事情。我们研究这些是出于学习目的，而不是为了协助进行非法活动。

## 回顾密码学的基本概念

在探讨Go语言中的加密之前，让我们复习一些基本的加密概念。长话短说吧。

首先，加密（出于维护机密性的目的）只是加密的任务之一。*Encryption*，通常来说是双向的，可以对数据加密，然后解密恢复初始的输入。加密数据的过程使得它在被解密之前毫无意义。

加密和解密都涉及到将数据和附带的密钥传递到加密函数。该函数输出加密的数据（称为密文）或原始的可读数据（称为明文）。有多种算法实现。`Symmetric` 算法在加解密时使用相同的秘钥，而 `asymmetric` 使用不同的秘钥。您可能会使用加密来保护传输中的数据或存储敏感信息（例如信用卡号），以便日后解密，这可能是为了方便将来的购买或欺骗监控。 

另一方面，`hashing`是用于对数据进行数学扰乱的单向过程。可以将敏感信息传递到哈希函数来生成固定长度的输出。当使用强大的算法（例如SHA-2系列算法）时，不同输入产生相同输出的可能性非常低。即，发生碰撞的可能性低。由于哈希是不可逆的，因此通常用作在数据库中存储明文密码或执行完整性校验以确定数据是否被更改过。如果需要模糊或随机化两个相同输入的输出，可以使用 `salt`，这是一个随机值，用于在哈希过程中区分两个相同的输入。`salt` 通常用于密码存储，因为允许同时使用相同密码的多个用户仍然生成不同的哈希值。

密码学还提供了对消息进行身份验证的方法。`message authentication code (MAC)` 是由一个特殊的单向加密函数产生的输出。这个函数使用数据本身、一个密钥和一个初始化向量，并生成一个不太可能发生冲突的输出。消息的发送者执行生成MAC的功能，然后将MAC作为消息的一部分。接收方在本地计算MAC并将其与接收到的MAC进行比较。匹配成功表明发送方拥有正确的密钥（即发送方是可信的），并且消息没有被更改（即保持了完整性）。

现在到这，应该对密码学有足够的了解了，可以理解本章的内容。必要时，我们将讨论与给定主题相关的更多细节。先从Go的标准加密库开始吧。

## 搞懂标准加密库

在Go中实现加密的妙处在于，使用的大多数加密功能都来自于标准库。其他语言通常依赖于OpenSSL或其他第三方库，而Go的加密功能是官方库的一部分。这使得加密的实现相对简单，因为不必安装会污染开发环境的笨重的依赖项。有两个独立的库。

标准库的`crypto`包中有各种常见的加密和算法相关的子包。例如，可以使用 `aes`，`des`和`rc4`子包来实现对称密钥算法。用于非对称加密的有`dsa`和`rsa`子包；以及用于哈希的`md5`，`sha1`，`sha256`和`sha512`子包。这不是全部；另外还有用于其他加密的子包。

除了标准的 `crypto` 包，Go还有一个官方的扩展包，包含各种加密功能：`golang.org/x/crypto`。功能包括其他哈希算法，加密算法和通用功能。例如，该包中有用于*bcrypt hashing*的`bcrypt`子包（一种用于哈希密码和敏感数据的更好，更安全的替代方法），用于生成合法证书的`acme/autocert` 以及方便SSH协议通信的SSH子包。

内置`crypto`包和补充的`golang.org/x/crypto`包之间唯一真正的区别是，`crypto`包遵循更严格的兼容性要求。另外，要使用`golang .org/x/crypto`中的子包，则首先需要输入以下内容来安装该软件包：

```sh
$ go get -u golang.org/x/crypto/bcrypt
```

Go官方的 `crypto`包中所有功能和子包的完整列表，请参阅 `https://golang.org/pkg/crypto/` 和 `https://godoc.org/golang.org/x/crypto/`。

下一节将深入探讨各种加密实现。将会展示如何使用Go的加密功能来做一些邪恶的事情，例如破解密码哈希，使用静态密钥解密敏感数据以及暴力破解弱加密密码。还将使用该功能来创建使用TLS来保护传输中的通信，检查数据的完整性和真实性以及执行相互身份验证的工具。

### 探索哈希

如前所述，哈希是一种单向函数，用于根据变长输入生成固定长度、概率唯一的输出。不能反向哈希值来恢复原始输入数据。哈希通常用于存储原始明文数据，以后不再处理或验证数据的完整性。例如，糟糕的做法是存储明文密码；相反，应该存储哈希（最好是加点佐料，以确保重复值之间的随机性）。

通过两个例子来演示Go中的哈希。第一个例子是尝试使用离线字典来破解给定的MD5或SHA-512哈希。第二个例子是演示 `bcrypt` 的实现。如前所述，`bcrypt` 是一种用于哈希敏感数据（例如密码）的更安全的算法。该算法还有降低其速度的功能，这使得破解密码更加困难。

#### 破解MD5或SHA-512哈希

清单11-1是哈希破解代码。（`/`根目录中的所有代码都在github 仓库 `https://github.com/blackhat-go/bhg/` 中。）由于哈希不是可逆的，因此代码会尝试通过生成常见单词（从单词列表中提取）的哈希，然后将生成的哈希值与当前的哈希进行比较，来猜测哈希的明文。如果两个哈希值匹配，则可能就猜到了明文值。

```go
var md5hash = "77f62e3524cd583d698d51fa24fdff4f"
var sha256hash = "95a5e1547df73abdd4781b6c9e55f3377c15d08884b11738c2727dbd887d4ced"
func main() {
	f, err := os.Open("wordlist.txt")
    if err != nil {
		log.Fatalln(err) 
    }
	defer f.Close()
	scanner := bufio.NewScanner(f) 
    for scanner.Scan() {
		password := scanner.Text()
		hash := fmt.Sprintf("%x", md5.Sum([]byte(password))x) 
        if hash == md5hash {
			fmt.Printf("[+] Password found (MD5): %s\n", password) 
        }
		hash = fmt.Sprintf("%x", sha256.Sum256([]byte(password))) 
        if hash == sha256hash {
			fmt.Printf("[+] Password found (SHA-256): %s\n", password) 
        }
	}
	if err := scanner.Err(); err != nil { 
        log.Fatalln(err)
	} 
}
```

清单 11-1: 破解 MD5 和 SHA-256 哈希 (/ch-11/hashes/main.go)

首先定义两个保存目标哈希值的变量。一个是MD5 哈希，另一个是SHA-256 哈希。想象一下，您是在后漏洞阶段获取了这两个哈希，并试图通过运行散列算法生成它们的输入（明文密码）。通常可以通过检查哈希值的长度来确定算法。找到与目标匹配的哈希后，就知道是正确的输入了。

使用之前创建的字典文件作为输入列表。另外，谷歌一下可以帮助找到常用密码的字典文件。要检查MD5哈希，请打开字典文件并通过在文件描述符上创建 `bufio.Scanner` 逐行读取。每行是一个要检查的密码。将当前密码传递给 `md5.Sum(input [] byte)` 函数。此函数生成原生的MD5哈希值，因此可以使用 `fmt.Sprintf()` 函数和格式字符串 `％x`将其转换为十六进制字符串。毕竟，`md5hash` 变量由目标哈希的十六进制格式的字符串组成。转换该值可确保随后可以比较目标哈希值和计算得出的哈希值。如果这些哈希匹配，则程序会向stdout输出一条成功消息。

执行类似的过程来计算和比较SHA-256哈希。该实现与MD5代码非常相似。唯一真正的区别是，`sha256`包中有计算各种SHA散列长度的附加函数。与其调用 `sha256. sum()` （一个不存在的函数），不如调用 `sha256.Sum256(input []byte)` 强制使用SHA-256算法计算哈希值。就像在MD5示例中所做的一样，将原始字节转换为十六进制字符串，并比较SHA-256哈希值以查看是否有匹配项