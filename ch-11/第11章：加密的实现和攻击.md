没有密码学的安全交流是不完整的。当组织使用加密方法时，它们可以帮助保护其信息和系统的完整性，机密性和真实性。作为工具开发人员，可能需要实现加密功能，可能用于 **SSL/TLS** 通信，相互身份验证，对称密钥加密或密码哈希。但是开发人员通常不安全地实现加密功能，这意味着有攻击意识的人可以利用这些弱点来破坏敏感的，有价值的数据，例如社保或信用卡号。

本章演示了Go中加密的各种实现，并讨论可以利用的常见弱点。虽然我们介绍不同的密码函数和代码块，但我们不探索密码算法或数学原理的细微差别。坦率地说，这远远超出了我们对密码学的兴趣（或知识）。如前所述，在未经所有者明确许可的情况下，请勿在本章中对资源或资产做任何事情。我们研究这些是出于学习目的，而不是为了协助进行非法活动。

## 回顾密码学的基本概念

在探讨Go语言中的加密之前，让我们复习一些基本的加密概念。长话短说吧。

首先，加密（出于维护机密性的目的）只是加密的任务之一。*Encryption*，通常来说是双向的，可以对数据加密，然后解密恢复初始的输入。加密数据的过程使得它在被解密之前毫无意义。

加密和解密都涉及到将数据和附带的密钥传递到加密函数。该函数输出加密的数据（称为密文）或原始的可读数据（称为明文）。有多种算法实现。`Symmetric` 算法在加解密时使用相同的秘钥，而 `asymmetric` 使用不同的秘钥。您可能会使用加密来保护传输中的数据或存储敏感信息（例如信用卡号），以便日后解密，这可能是为了方便将来的购买或欺骗监控。 

另一方面，`hashing`是用于对数据进行数学扰乱的单向过程。可以将敏感信息传递到哈希函数来生成固定长度的输出。当使用强大的算法（例如SHA-2系列算法）时，不同输入产生相同输出的可能性非常低。即，发生碰撞的可能性低。由于哈希是不可逆的，因此通常用作在数据库中存储明文密码或执行完整性校验以确定数据是否被更改过。如果需要模糊或随机化两个相同输入的输出，可以使用 `salt`，这是一个随机值，用于在哈希过程中区分两个相同的输入。`salt` 通常用于密码存储，因为允许同时使用相同密码的多个用户仍然生成不同的哈希值。

密码学还提供了对消息进行身份验证的方法。`message authentication code (MAC)` 是由一个特殊的单向加密函数产生的输出。这个函数使用数据本身、一个密钥和一个初始化向量，并生成一个不太可能发生冲突的输出。消息的发送者执行生成MAC的功能，然后将MAC作为消息的一部分。接收方在本地计算MAC并将其与接收到的MAC进行比较。匹配成功表明发送方拥有正确的密钥（即发送方是可信的），并且消息没有被更改（即保持了完整性）。

现在到这，应该对密码学有足够的了解了，可以理解本章的内容。必要时，我们将讨论与给定主题相关的更多细节。先从Go的标准加密库开始吧。

## 搞懂标准加密库

在Go中实现加密的妙处在于，使用的大多数加密功能都来自于标准库。其他语言通常依赖于OpenSSL或其他第三方库，而Go的加密功能是官方库的一部分。这使得加密的实现相对简单，因为不必安装会污染开发环境的笨重的依赖项。有两个独立的库。

标准库的`crypto`包中有各种常见的加密和算法相关的子包。例如，可以使用 `aes`，`des`和`rc4`子包来实现对称密钥算法。用于非对称加密的有`dsa`和`rsa`子包；以及用于哈希的`md5`，`sha1`，`sha256`和`sha512`子包。这不是全部；另外还有用于其他加密的子包。

除了标准的 `crypto` 包，Go还有一个官方的扩展包，包含各种加密功能：`golang.org/x/crypto`。功能包括其他哈希算法，加密算法和通用功能。例如，该包中有用于*bcrypt hashing*的`bcrypt`子包（一种用于哈希密码和敏感数据的更好，更安全的替代方法），用于生成合法证书的`acme/autocert` 以及方便SSH协议通信的SSH子包。

内置`crypto`包和补充的`golang.org/x/crypto`包之间唯一真正的区别是，`crypto`包遵循更严格的兼容性要求。另外，要使用`golang .org/x/crypto`中的子包，则首先需要输入以下内容来安装该软件包：

```sh
$ go get -u golang.org/x/crypto/bcrypt
```

Go官方的 `crypto`包中所有功能和子包的完整列表，请参阅 `https://golang.org/pkg/crypto/` 和 `https://godoc.org/golang.org/x/crypto/`。

下一节将深入探讨各种加密实现。将会展示如何使用Go的加密功能来做一些邪恶的事情，例如破解密码哈希，使用静态密钥解密敏感数据以及暴力破解弱加密密码。还将使用该功能来创建使用TLS来保护传输中的通信，检查数据的完整性和真实性以及执行相互身份验证的工具。

