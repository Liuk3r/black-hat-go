没有密码学的安全交流是不完整的。当组织使用加密方法时，它们可以帮助保护其信息和系统的完整性，机密性和真实性。作为工具开发人员，可能需要实现加密功能，可能用于 **SSL/TLS** 通信，相互身份验证，对称密钥加密或密码哈希。但是开发人员通常不安全地实现加密功能，这意味着有攻击意识的人可以利用这些弱点来破坏敏感的，有价值的数据，例如社保或信用卡号。

本章演示了Go中加密的各种实现，并讨论可以利用的常见弱点。虽然我们介绍不同的密码函数和代码块，但我们不探索密码算法或数学原理的细微差别。坦率地说，这远远超出了我们对密码学的兴趣（或知识）。如前所述，在未经所有者明确许可的情况下，请勿在本章中对资源或资产做任何事情。我们研究这些是出于学习目的，而不是为了协助进行非法活动。

## 回顾密码学的基本概念

在探讨Go语言中的加密之前，让我们复习一些基本的加密概念。长话短说吧。

首先，加密（出于维护机密性的目的）只是加密的任务之一。*Encryption*，通常来说是双向的，可以对数据加密，然后解密恢复初始的输入。加密数据的过程使得它在被解密之前毫无意义。

加密和解密都涉及到将数据和附带的密钥传递到加密函数。该函数输出加密的数据（称为密文）或原始的可读数据（称为明文）。有多种算法实现。`Symmetric` 算法在加解密时使用相同的秘钥，而 `asymmetric` 使用不同的秘钥。您可能会使用加密来保护传输中的数据或存储敏感信息（例如信用卡号），以便日后解密，这可能是为了方便将来的购买或欺骗监控。 

另一方面，`hashing`是用于对数据进行数学扰乱的单向过程。可以将敏感信息传递到哈希函数来生成固定长度的输出。当使用强大的算法（例如SHA-2系列算法）时，不同输入产生相同输出的可能性非常低。即，发生碰撞的可能性低。由于哈希是不可逆的，因此通常用作在数据库中存储明文密码或执行完整性校验以确定数据是否被更改过。如果需要模糊或随机化两个相同输入的输出，可以使用 `salt`，这是一个随机值，用于在哈希过程中区分两个相同的输入。`salt` 通常用于密码存储，因为允许同时使用相同密码的多个用户仍然生成不同的哈希值。

密码学还提供了对消息进行身份验证的方法。`message authentication code (MAC)` 是由一个特殊的单向加密函数产生的输出。这个函数使用数据本身、一个密钥和一个初始化向量，并生成一个不太可能发生冲突的输出。消息的发送者执行生成MAC的功能，然后将MAC作为消息的一部分。接收方在本地计算MAC并将其与接收到的MAC进行比较。匹配成功表明发送方拥有正确的密钥（即发送方是可信的），并且消息没有被更改（即保持了完整性）。

现在到这，应该对密码学有足够的了解了，可以理解本章的内容。必要时，我们将讨论与给定主题相关的更多细节。先从Go的标准加密库开始吧。

## 搞懂标准加密库

在Go中实现加密的妙处在于，使用的大多数加密功能都来自于标准库。其他语言通常依赖于OpenSSL或其他第三方库，而Go的加密功能是官方库的一部分。这使得加密的实现相对简单，因为不必安装会污染开发环境的笨重的依赖项。有两个独立的库。

标准库的`crypto`包中有各种常见的加密和算法相关的子包。例如，可以使用 `aes`，`des`和`rc4`子包来实现对称密钥算法。用于非对称加密的有`dsa`和`rsa`子包；以及用于哈希的`md5`，`sha1`，`sha256`和`sha512`子包。这不是全部；另外还有用于其他加密的子包。

除了标准的 `crypto` 包，Go还有一个官方的扩展包，包含各种加密功能：`golang.org/x/crypto`。功能包括其他哈希算法，加密算法和通用功能。例如，该包中有用于*bcrypt hashing*的`bcrypt`子包（一种用于哈希密码和敏感数据的更好，更安全的替代方法），用于生成合法证书的`acme/autocert` 以及方便SSH协议通信的SSH子包。

内置`crypto`包和补充的`golang.org/x/crypto`包之间唯一真正的区别是，`crypto`包遵循更严格的兼容性要求。另外，要使用`golang .org/x/crypto`中的子包，则首先需要输入以下内容来安装该软件包：

```sh
$ go get -u golang.org/x/crypto/bcrypt
```

Go官方的 `crypto`包中所有功能和子包的完整列表，请参阅 `https://golang.org/pkg/crypto/` 和 `https://godoc.org/golang.org/x/crypto/`。

下一节将深入探讨各种加密实现。将会展示如何使用Go的加密功能来做一些邪恶的事情，例如破解密码哈希，使用静态密钥解密敏感数据以及暴力破解弱加密密码。还将使用该功能来创建使用TLS来保护传输中的通信，检查数据的完整性和真实性以及执行相互身份验证的工具。

## 探索哈希

如前所述，哈希是一种单向函数，用于根据变长输入生成固定长度、概率唯一的输出。不能反向哈希值来恢复原始输入数据。哈希通常用于存储原始明文数据，以后不再处理或验证数据的完整性。例如，糟糕的做法是存储明文密码；相反，应该存储哈希（最好是加点佐料，即随机值，以确保重复值之间的随机性）。

通过两个例子来演示Go中的哈希。第一个例子是尝试使用离线字典来破解给定的MD5或SHA-512哈希。第二个例子是演示 `bcrypt` 的实现。如前所述，`bcrypt` 是一种用于哈希敏感数据（例如密码）的更安全的算法。该算法还有降低其速度的功能，这使得破解密码更加困难。

### 破解MD5或SHA-512哈希

清单11-1是哈希破解代码。（`/`根目录中的所有代码都在github 仓库 `https://github.com/blackhat-go/bhg/` 中。）由于哈希不是可逆的，因此代码会尝试通过生成常见单词（从单词列表中提取）的哈希，然后将生成的哈希值与当前的哈希进行比较，来猜测哈希的明文。如果两个哈希值匹配，则可能就猜到了明文值。

```go
var md5hash = "77f62e3524cd583d698d51fa24fdff4f"
var sha256hash = "95a5e1547df73abdd4781b6c9e55f3377c15d08884b11738c2727dbd887d4ced"
func main() {
	f, err := os.Open("wordlist.txt")
    if err != nil {
		log.Fatalln(err) 
    }
	defer f.Close()
	scanner := bufio.NewScanner(f) 
    for scanner.Scan() {
		password := scanner.Text()
		hash := fmt.Sprintf("%x", md5.Sum([]byte(password))x) 
        if hash == md5hash {
			fmt.Printf("[+] Password found (MD5): %s\n", password) 
        }
		hash = fmt.Sprintf("%x", sha256.Sum256([]byte(password))) 
        if hash == sha256hash {
			fmt.Printf("[+] Password found (SHA-256): %s\n", password) 
        }
	}
	if err := scanner.Err(); err != nil { 
        log.Fatalln(err)
	} 
}
```

清单 11-1: 破解 MD5 和 SHA-256 哈希 (/ch-11/hashes/main.go)

首先定义两个保存目标哈希值的变量。一个是MD5 哈希，另一个是SHA-256 哈希。想象一下，您是在后漏洞阶段获取了这两个哈希，并试图通过运行散列算法生成它们的输入（明文密码）。通常可以通过检查哈希值的长度来确定算法。找到与目标匹配的哈希后，就知道是正确的输入了。

使用之前创建的字典文件作为输入列表。另外，谷歌一下可以帮助找到常用密码的字典文件。要检查MD5哈希，请打开字典文件并通过在文件描述符上创建 `bufio.Scanner` 逐行读取。每行是一个要检查的密码。将当前密码传递给 `md5.Sum(input [] byte)` 函数。此函数生成原生的MD5哈希值，因此可以使用 `fmt.Sprintf()` 函数和格式字符串 `％x`将其转换为十六进制字符串。毕竟，`md5hash` 变量由目标哈希的十六进制格式的字符串组成。转换该值可确保随后可以比较目标哈希值和计算得出的哈希值。如果这些哈希匹配，则程序会向stdout输出一条成功消息。

执行类似的过程来计算和比较SHA-256哈希。该实现与MD5代码非常相似。唯一真正的区别是，`sha256`包中有计算各种SHA散列长度的附加函数。与其调用 `sha256. sum()` （一个不存在的函数），不如调用 `sha256.Sum256(input []byte)` 强制使用SHA-256算法计算哈希值。就像在MD5示例中所做的一样，将原始字节转换为十六进制字符串，并比较SHA-256哈希值以查看是否有匹配项。

#### 实现 **bcrypt**

下一个示例展示了如何使用 `bcrypt` 加密和验证密码。与SHA和MD5不同，`bcrypt` 是为密码哈希设计的，与SHA或MD5系列相比，它成为程序员的更好选择。默认情况下， `bcrypt` 包含一个”佐料“，以及一个运行该算法更加耗费资源的成本因素。该成本因素控制着内部加密函数的迭代次数，从而增加了破解密码哈希所需的时间和精力。尽管仍然可以使用字典或暴力来破解密码，但是成本（时间）会显着增加，从而阻止了对时间敏感的漏洞后的破解。随着时间的推移，还可能会增加成本，以应对计算能力的提高。这使其可以适应将来的破解攻击。

清单11-2创建了一个bcrypt哈希，然后验证明文密码是否与给定的bcrypt哈希匹配。

```go
import ( 
    "log"
 	"os"
    "golang.org/x/crypto/bcrypt"
)
var storedHash = "$2a$10$Zs3ZwsjV/nF.KuvSUE.5WuwtDrK6UVXcBpQrH84V8q3Opg1yNdWLu"

func main() {
	var password string
	if len(os.Args) != 2 {
		log.Fatalln("Usage: bcrypt password") 
    }
	password = os.Args[1]
    hash, err := bcrypt.GenerateFromPassword( 
        []byte(password),
		bcrypt.DefaultCost, 
    )
    if err != nil { 
        log.Fatalln(err)
	}
	log.Printf("hash = %s\n", hash)
    err = bcrypt.CompareHashAndPassword([]byte(storedHash), []byte(password)) 
    if err != nil {
		log.Println("[!] Authentication failed")
		return 
    }
	log.Println("[+] Authentication successful")
}
```

清单 11-2: 比较 bcrypt 哈希 (/ch-11/bcrypt/main.go)

对于本书中的大多数代码示例，都省略了包的导入。在此示例中包含了它们，以明确表示正在使用补充的Go包`golang.org/x/crypto/bcrypt`，因为Go的标准包中没有 `bcrypt` 相关功能。然后，初始化变量 `storedHash`，该变量包含一个预先计算的，`bcrypt` 编码的哈希。这是为了演示设计的例子;的目的，硬编码一个值，而不是将示例代码连接到数据库来获取值。例如，该变量可能表示数据库中某一行值，该行存储了前端Web程序的用户身份验证信息。

接下来，根据明文密码值生成一个经过bcrypt编码的哈希。main函数读取密码值作为命令行参数，然后继续调用两个单独的bcrypt函数。第一个函数 `bcrypt.GenerateFromPassword()`接受两个参数：一个字节切片(表示明文密码)和一个成本。在此示例中，使用包里的默认值 `bcrypt.DefaultCost` 常量，在撰写本文时，该默认值为10。该函数返回编码的哈希值和产生的任何错误。

第二个调用的bcrypt函数是` bcrypt.CompareHashAndPassword()` ， 用来进行哈希比较。它接受bcrypt编码的哈希和明文密码作为字节切片。该函数解析编码的哈希，以确定成本和随机值。然后，将这些值与明文密码值一起生成bcrypt哈希。如果生成的哈希值与从已编码的`storedHash` 值提取的哈希值匹配，则提供的密码与用于创建 `storedHash`的密码匹配。这是用于对SHA和MD5进行密码破解的方法，即通过哈希函数运行给定密码并将结果与存储的哈希进行比较。这里，不像SHA和MD5那样明确地比较生成的哈希，而是检查`bcrypt.CompareHashAndPassword()` 是否返回错误。如果有错误，则说明计算出的哈希值是正确的，因此用于计算它们的密码不匹配。

以下是两个示例程序运行。第一个是不正确密码的输出：

```sh
$ go run main.go someWrongPassword
2020/08/25 08:44:01 hash = $2a$10$YSSanGl8ye/NC7GDyLBLUO5gE/ng51l9TnaB1zTChWq5g9i09v0AC 
2020/08/25 08:44:01 [!] Authentication failed
```

第二个是正确密码的输出：

```sh
$ go run main.go someC0mpl3xP@ssw0rd
2020/08/25 08:39:29 hash = $2a$10$XfeUk.wKeEePNAfjQ1juXe8RaM/9EC1XZmqaJ8MoJB29hZRyuNxz. 
2020/08/25 08:39:29 [+] Authentication successful
```

细心的可能会注意到，身份验证成功的显示的哈希与 `storedHash` 变量硬编码的值不匹配。回想下，代码调用了两个独立的函数。`GenerateFromPassword()` 函数使用随机值生成编码的哈希。使用不同的随机值，相同的密码将产生不同结果的哈希。因此,不同。`CompareHashAndPassword()` 函数通过使用与存储的哈希相同的随机值和成本来执行哈希算法，因此生成的哈希与`storedHash`变量中的哈希相同。

## 验证消息

现在将重点转向消息验证。交换消息时，需要验证数据的完整性和远程服务的真实性，以确保数据是真实且未被篡改的。消息在传输过程中是否被未经授权的来源更改？消息是由授权方发送的，还是由别的实体伪造的?

可以使用Go的`crypto/hmac` 包解决这些问题，该包实现了*Keyed-Hash Message Authentication Code* (HMAC)标准。HMAC是一种加密算法，可让检查消息是否被篡改并验证源身份。它使用哈希函数并使用共享的密钥，只有被授权产生有效消息或数据的各方才应拥有该密钥。没有共享此秘钥的攻击者无法伪造有效的HMAC值。在某些编程语言中实现HMAC可能会有些棘手。例如，某些语言会强制逐字节手动比较接收到的哈希值和计算得出的哈希值。如果开发人员过早地逐字节比较其结果，则开发人员可能会在此过程中无意中引入时序差异。攻击者可以通过测量消息处理时间来推断出预期的HMAC。此外，开发人员有时会认为HMAC（消耗一条消息和密钥）与消息之前的密钥的哈希值相同。但是，HMAC的内部不同于纯哈希功能。通过不明确地使用HMAC，开发人员会将应用程序暴露于长度扩展攻击中，在这种攻击中，攻击者会伪造消息和有效的MAC。

对我们Gophers来说幸运的是，crypto/hmac包使安全的方式实现HMAC功能变得相当容易。来看一个实现。注意，以下程序比典型的用例简单得多，后者可能涉及某种类型的网络通信和消息传递。在大多数情况下，可以根据HTTP请求参数或通过网络传输的其他消息来计算HMAC。在清单11-3所示的示例中，省略了客户端与服务器之间的通信，只看HMAC功能。

```go
var key = []byte("some random key")
func checkMAC(message, recvMAC []byte) bool {
    mac := hmac.New(sha256.New, key)
    mac.Write(message)
	calcMAC := mac.Sum(nil)
	return hmac.Equal(calcMAC, recvMAC)
}
func main() {
	// In real implementations, we’d read the message and HMAC value from network source
	message := []byte("The red eagle flies at 10:00") 	
	mac, _ := hex.DecodeString("69d2c7b6fbbfcaeb72a3172f4662601d1f16acfb46339639ac8c10c8da64631d")
    if checkMAC(message, mac) {
		fmt.Println("EQUAL") 
    } else {
		fmt.Println("NOT EQUAL") 
    }
}
```

清单 11-3: 使用HMAC进行消息身份验证 (/ch-11/hmac/main.go)

程序首先定义要用于HMAC加密的密钥。也就在这里使用硬编码，但在实际的实现中，此密钥将受到充分保护并且是随机的。该秘钥也将在端点之间共享，意味着消息发送方和接收方使用此相同的秘钥。由于未实现完整的客户端-服务器功能，所以使用这个变量，就好像它已被充分共享一样。

接下来，定义 `checkMAC()` 函数，以消息和接收到的HMAC作为参数。消息接收者将调用此函数以检查他们接收到的MAC值是否与他们在本地计算的值匹配。首先，调用 `hmac.New()` ，实参为 `sha256.New` 和 `key`，返回 `hash.Hash` 实例。在这个例子中，`hmac.New()` 函数通过使用SHA-256算法和密钥来初始化HMAC，并将结果分配给名为mac的变量。然后，可以使用此变量来计算HMAC哈希值，就像在前面的哈希示例中所做的那样。在这里，分别调用 `mac.Write(message)` 和 `mac.Sum(nil)` 。将本地计算的HMAC结果存储在名为`calcMAC` 的变量中。

下一步是比较本地计算的HMAC值是否等于收到的HMAC值。要以一种安全的方式做到这一点，可以调用 `hmac.Equal(calcMAC, recvMAC)` 。许多开发人员倾向于通过调用 `bytes.Compare(calcMAC, recvMAC)` 来比较字节片。问题是，`bytes.Compare()` 执行字典比较，遍历并比较给定切片的每个元素，直到找到差异或到达切片的末尾。比较所需的时间将根据`bytes.Compare()`在第一个元素，最后一个元素或两者之间的某个地方是否有所不同而不同。攻击者可能会及时测量这种变化，以确定预期的HMAC值并伪造合法处理的请求。`hmac.Equal()` 函数通过几乎相同的时间的方式比较切片来解决此问题。函数在何处发现差异都无所谓，因为处理时间变化不大，不会产生明显或可察觉的形式。

`main()` 函数模拟从客户端接收消息的过程。如果确实收到了一条消息，则必须从传输中读取并解析HMAC和消息。由于这只是一个模拟，因此可以对接收到的消息和接收到的HMAC进行硬编码，然后对HMAC十六进制字符串进行解码，以便将其转换成 `[]byte`。可以使用if语句来调用 `checkMAC()`函数，并将接收到的消息和HMAC传递给该函数。如前所述，`checkMAC() 函数通过使用接收到的消息和共享密钥来计算HMAC，并返回布尔值来确定接收到的HMAC和计算出的HMAC是否匹配。

尽管HMAC确实提供了真实性和完整性保证，但它不能确保私密性。无法确定是否未经授权的源看不到该消息。下一部分将通过探索和实现各种类型的加密来解决此问题。

## 加密数据

加密可能是最著名的加密概念。毕竟，隐私和数据保护由于备受瞩目的数据泄露而获得了大量新闻报道，这通常是由于未以加密格式存储了用户密码和其他敏感数据。即使没有媒体的注意，加密也应该引起黑帽和开发人员的关注。毕竟，了解基本过程和实现可能是有利可图的数据泄露与令人沮丧的攻击终止链之间的区别。下一节介绍了各种加密形式，包括有用的应用程序和每种用例。

### 对称密钥加密

以最直接的形式——对称密钥加密，进入加密之旅。这种模式是加密和解密都使用相同的密钥。Go使对称密码学变得非常简单，因为默认包或扩展包支持大多数常用算法。

为了简洁，在一个示例中讲解对称密钥加密。假设要攻击一个组织。已经执行了必要的权限升级，横向移动和网络侦察，才能访问电子商务Web服务器和后端数据库。该数据库中有金融交易；但是，显然这些交易中使用的信用卡号已加密。检查Web服务器上的应用程序源代码，并确定组织正在使用高级加密标准（AES）的加密算法。AES支持多种操作方式，每种方式都有不同的注意事项和实现细节。方式间是不可互换的。用于解密的方式必须与用于加密的方式相同。

在这种情况下，假设确定应用程序正在以密码块链接（CBC）方式使用AES。因此，让我们编写一个解密这些信用卡的功能（清单11-4）。假设对称密钥已在应用程序中进行了硬编码或在配置文件中进行了静态设置。在阅读本示例时，请记住，需要针对其他算法或密码调整此实现，但这是一个很好的起点。

```go
func unpad(buf []byte) []byte {
	// Assume valid length and padding. Should add checks padding := int(buf[len(buf)-1])
	return buf[:len(buf)-padding]
}

func decrypt(ciphertext, key []byte) ([]byte, error) {
    var (
		plaintext []byte
		iv []byte
		block cipher.Block 
        mode cipher.BlockMode
    	err error 
    )
    
	if len(ciphertext) < aes.BlockSize {
		return nil, errors.New("Invalid ciphertext length: too short")
	}
    
	if len(ciphertext)%aes.BlockSize != 0 {
		return nil, errors.New("Invalid ciphertext length: not a multiple of blocksize")
	}
    
	iv = ciphertext[:aes.BlockSize]
    ciphertext = ciphertext[aes.BlockSize:]
    
	if block, err = aes.NewCipher(key); err != nil {
        return nil, err
	}
	mode = cipher.NewCBCDecrypter(block, iv)
    plaintext = make([]byte, len(ciphertext)) 
    mode.CryptBlocks(plaintext, ciphertext)
    plaintext = unpad(plaintext)}

    return plaintext, nil
}
```

清单 11-4: AES填充和解密 (/ch-11/aes/main.go)

代码中定义了两个函数：` unpad()` 和 `decrypt()` 。`unpad()` 函数是一个整合在一起的通用函数，用于处理解密后填充数据的删除。这是必要的步骤，但超出了此讨论的范围。有关更多信息请查阅 Public Key Cryptography Standards (PKCS) #7 。这是AES的一个相关主题，因为它用于确保我们的数据具有正确的块对齐方式。对于此示例，只知道以后需要使用该功能来清理数据。该函数本身假设要在实际场景中已明确验证了一些事实。具体来说，需要确认填充字节的值是否有效，切片偏移量是否有效以及结果的长度是否合适。

最有趣的逻辑存在于 `delete()` 函数中，该函数使用两个字节切片：需要解密的密文和用于执行此操作的对称密钥。该函数先执行一些验证，至少确认密文与块大小长度相等。这是必要的步骤，因为CBC模式加密使用初始向量（IV）来实现随机性。该IV就像密码哈希的随机值一样，不需要保密。IV与单个AES块的长度相同，在加密过程中会加在密文上。如果密文长度小于预期的块大小，则说明密文有问题或缺少IV。还检查密文长度是否为AES块大小的倍数。否则，解密将失败，因为CBC模式期望密文长度为块大小的倍数。

完成验证检查后，可以继续解密密文。如前所述，IV是加在密文之前的，因此要做的第一件事是从密文中提取IV。可以使用 `aes.BlockSize` 常量来检索IV，然后通过 `ciphertext = [aes.BlockSize:]` 将密文变量重新定义为密文的其余部分。现在，已将加密数据与IV分开了。

接下来，调用 `aes.NewCipher()` ，并向其传递对称密钥。这将初始化AES块模式密码，并将其分配给名为 `block` 的变量。然后，通过调用 `cipher.NewCBCDecryptor(block,iv) 来明确AES密码以CBC模式运行。将结果赋值给名为 `mode` 的变量。（crypto/cipher包中有用于其他AES模式的初始化功能，但此处仅使用CBC解密。）然后，调用 `mode.CryptBlocks(plaintext，ciphertext)` ，用来解密密文的内容，并将结果存储在纯文本字节切片中。最后，通过调用 `unpad()` 通用函数来删除PKCS＃7填充。返回结果。如果一切正常，这应该是信用卡号的纯文本值。

运行该示例，生成预期的结果：

```sh
$ go run main.go
key = aca2d6b47cb5c04beafc3e483b296b20d07c32db16029a52808fde98786646c8
ciphertext = 7ff4a8272d6b60f1e7cfc5d8f5bcd047395e31e5fc83d062716082010f637c8f21150eabace62 
--snip--
plaintext = 4321123456789090
```

注意，没有在此示例代码中定义 `main()` 函数。为什么没有呢？嗯，在陌生环境中解密数据会产生各种潜在的细微差别和变化。例如，密文和密钥值是编码的还是原始二进制的？如果已编码，它们是十六进制字符串还是Base64？数据是否在本地可访问，还是需要从数据源中提取数据或与硬件安全模块进行交互？键是，解密很少是复制粘贴的工作，通常需要对算法，模式，数据库交互和数据编码有一定程度的了解。因此，我们选择引导您找到答案，期望您在适当的时候弄清楚。

只需了解一点对称密钥加密，就可以使渗透测试更加成功。例如，在我们窃取客户端源代码存储库的经验中，我们发现人们经常在CBC或Electronic Codebook（ECB）模式下使用AES加密算法。ECB模式有一些固有的弱点，如果使用不正确，CBC也不会更好。加密可能很难理解，因此开发人员经常认为所有加密密码和模式都同样有效，并且不了解其细微之处。尽管我们不认为自己是密码学家，但我们了解的知识足以在Go中安全地使用加密，并可以利用其他人的缺陷实现。

尽管对称密钥加密比非对称加密更快，但是它遭受内在的密钥管理挑战。毕竟，要使用它，必须将相同的密钥分发给对数据执行加密或解密的系统或应用程序。必须经常遵循严格的流程和审核机制，才能安全地分发密钥。此外，例如，仅依赖对称密钥加密可以防止任意客户机与其他节点建立加密通信。没有一种很好的方法来协商密钥，也没有许多常见算法和模式的身份验证或完整性保证。这意味着获得密钥的任何人，无论是经过授权的还是恶意的，都可以继续使用它。

这就是非对称密码学可以使用的地方。

### 非对称加密

与对称密钥加密相关的许多问题都可以通过非对称（或公钥）加密技术解决，该加密技术使用两个独立但在数学上相关的密钥。一个公开，而另一个私密。用私钥加密的数据只能用公钥解开，而用公钥加密的数据只能用私钥解开。如果私钥保护得当，且是私密的，那么使用公钥加密的数据仍然是私密的，因为需要严密保护的私钥来解密。不仅如此，还可以使用私钥对用户进行身份验证。用户可以使用私钥对消息签名，例如，公众可以使用公钥解密。

因此，有人可能会问：“有什么收获呢？如果公钥加密提供了所有这些保证，那么为什么我们还要使用对称密钥加密呢？”，这是个好问题！公钥加密的问题在于它的速度。它比对称加密要慢得多。为了获得两全其美的效果（并避免最坏的情况），通常混合使用：初始通信时使用非对称加密，建立加密通道以创建和交换对称密钥（通常称为 *会话秘钥*）。由于会话密钥非常小，因此使用公钥加密进行此过程几乎不需要任何开销。然后，客户端和服务器都有会话密钥的副本，可使后面的通信更快。

来看下公钥加密的几个常见用例。具体来说，加密，签名验证和相互认证。