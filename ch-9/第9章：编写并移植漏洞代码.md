在前面的大多数章节中，使用Go创建基础的网络攻击。开发了原生的TCP，HTTP，DNS，SMB，数据库交互和被动数据包捕捉。

本章侧重于识别和移植漏洞。首先，学习如何创建漏洞模糊器来发现程序的安全缺陷。然后，学习如何移植现有漏洞到Go中。最后，展示如何使用流行的工具来创建支持Go的shellcode。在本章结束时，应该对如何使用Go来发现缺陷以及如何使用它来编写和交付各种有效负载有了基本的了解。

## 创建模糊器

`Fuzzing`是一种向程序发送大量数据，试图迫使应用程序产生异常行为的技术。该行为可暴漏代码的错误或安全缺陷，稍后就可以使用这些缺陷。模糊一个程序还可能产生不希望看到的副作用，比如资源耗尽、内存损坏和服务中断。其中有些副作用对于bug猎人和开发人员来说是必要的，但不利于程序的稳定性。因此，始终在受控的实验室环境中执行模糊是非常重要的。就像在本书中讨论的大多数技巧一样，在没有所有者的明确授权下，不要模糊程序或系统。

本部分会创建两个模糊器。第一个检测使服务崩溃时输入的容量，并识别缓冲区溢出。第二个模糊器重播HTTP请求，循环通过可能的输入发现SQL注入。

### 缓冲区溢出模糊

*Buffer overflows* 发生在用户在输入中提交的数据超过了程序能申请到的内存。例如，用户能够提交5000字符，而程序只能接受5个。若程序使用了错误的技术，其能允许用户将多余的数据写入到不是为这些数据准备的内存中，这种“溢出”会破坏存储在相邻内存位置中的数据，能让恶意用户偷偷地使程序崩溃或改变其逻辑流。

缓冲区溢出对于从客户端接收数据的网络程序影响特别大。使用缓冲区溢出，客户端可能终端服务端的可用性，或执行远程代码。再重申下：除非得到允许，否则不要模糊系统或应用程序。另外，确保完全理解系统或程序崩溃的后果。

#### 缓冲区溢出模糊如何工作

模糊地创建缓冲区溢出通常需要提交越来越长的输入，例如，每个后续请求都包含比上次多一个字符的输入值。一个牵强的例子，使用A字符作为输入会按照表9-1中所示的方式执行。

**表9-1：** 在缓冲区溢出测试中的输入的值

| 次数 | 输入 |
| ---- | ---- |
| 1    | A    |
| 2    | AA   |
| 3    | AAA  |
| 4    | AAAA |
|      | N个A |

通过向一个易受攻击的函数发送大量输入，输入的长度最终会达到超过函数定义的缓冲区的大小，这会破坏程序的控制元素，例如其返回和指令指针。至此，程序或系统会崩溃。

每次尝试发送越来越大的请求，可以精确地确定预期的输入大小，这对之后开发程序非常重要。然后检查崩溃或核心输出结果，以便更好地理解漏洞并尝试开发一个有效的漏洞。在这里不讨论调试器的使用和开发；而要专注于编写模糊器。

如果用现代的解释语言做过手动模糊器，可能已经使用了构造器来创建指定长度的字符串。例如，下面的Python代码，在解释器控制台中运行，展示了创建一个有25个A字符的字符串是多么简单：

```python
>>> x = "A"*25
>>> x 
'AAAAAAAAAAAAAAAAAAAAAAAAA'
```

遗憾的是，Go中没有这么简便的构造器来构建任意长度的字符串。必须使用老风格的方式——使用循环——像下面这样的代码：

```go
var (
	n int
	s string 
)
for n = 0; n < 25; n++ { 
    s += "A"
}
```

显然，比Python有点冗长，但不难理解。

需要考虑的另一个问题是有效负载的传递机制。这依赖于目标程序或系统。在某些情况下，可能会涉及到向磁盘写入文件。另一些情况下，可能通过TCP/UDP与HTTP、SMTP、SNMP、FTP、Telnet或其他网络服务进行通信。

下面的例子中，将对远程FTP服务执行模糊测试。可以快速调整我们提供的许多逻辑来针对其他协议进行操作，因此它应该作为针对其他服务开发定制模糊器的良好基础。

虽然Go的标准包中包含对一些常见协议的支持，像HTTP和SMTP，但不支持客户端-服务器的FTP交互。可以使用支持FTP通信的第三方包代替，因此没必要从头开始写重复造轮子。然而，为了最大限度地控制（并欣赏该协议），使用原生的TCP通信来构建基础的FTP功能。如果需要回顾TCP是如何工作的，可以参考第2章。

