在前面的大多数章节中，使用Go创建基础的网络攻击。开发了原生的TCP，HTTP，DNS，SMB，数据库交互和被动数据包捕捉。

本章侧重于识别和移植漏洞。首先，学习如何创建漏洞混淆器来发现程序的安全缺陷。然后，学习如何移植现有漏洞到Go中。最后，展示如何使用流行的工具来创建支持Go的shellcode。在本章结束时，应该对如何使用Go来发现缺陷以及如何使用它来编写和交付各种有效负载有了基本的了解。

## 创建混淆器

`Fuzzing`是一种向程序发送大量数据，试图迫使应用程序产生异常行为的技术。该行为可暴漏代码的错误或安全缺陷，稍后就可以使用这些缺陷。混淆一个程序还可能产生不希望看到的副作用，比如资源耗尽、内存损坏和服务中断。其中有些副作用对于bug猎人和开发人员来说是必要的，但不利于程序的稳定性。因此，始终在受控的实验室环境中执行混淆是非常重要的。就像在本书中讨论的大多数技巧一样，在没有所有者的明确授权下，不要混淆程序或系统。

本部分会创建两个混淆器。第一个检测使服务崩溃时输入的容量，并识别缓冲区溢出。第二个混淆器重播HTTP请求，循环通过可能的输入发现SQL注入。

### 缓冲区溢出混淆

*Buffer overflows* 发生在用户在输入中提交的数据超过了程序能申请到的内存。例如，用户能够提交5000字符，而程序只能接受5个。若程序使用了错误的技术，其能允许用户将多余的数据写入到不是为这些数据准备的内存中，这种“溢出”会破坏存储在相邻内存位置中的数据，能让恶意用户偷偷地使程序崩溃或改变其逻辑流。

缓冲区溢出对于从客户端接收数据的网络程序影响特别大。使用缓冲区溢出，客户端可能终端服务端的可用性，或执行远程代码。再重申下：除非得到允许，否则不要混淆系统或应用程序。另外，确保完全理解系统或程序崩溃的后果。

#### 缓冲区溢出混淆如何工作

混淆地创建缓冲区溢出通常需要提交越来越长的输入，例如，每个后续请求都包含比上次多一个字符的输入值。一个牵强的例子，使用A字符作为输入会按照表9-1中所示的方式执行。

**表9-1：** 在缓冲区溢出测试中的输入的值

| 次数 | 输入 |
| ---- | ---- |
| 1    | A    |
| 2    | AA   |
| 3    | AAA  |
| 4    | AAAA |
|      | N个A |

通过向一个易受攻击的函数发送大量输入，输入的长度最终会达到超过函数定义的缓冲区的大小，这会破坏程序的控制元素，例如其返回和指令指针。至此，程序或系统会崩溃。

每次尝试发送越来越大的请求，可以精确地确定预期的输入大小，这对之后开发程序非常重要。然后检查崩溃或核心输出结果，以便更好地理解漏洞并尝试开发一个有效的漏洞。在这里不讨论调试器的使用和开发；而要专注于编写混淆器。

如果用现代的解释语言做过手动混淆器，可能已经使用了构造器来创建指定长度的字符串。例如，下面的Python代码，在解释器控制台中运行，展示了创建一个有25个A字符的字符串是多么简单：

```python
>>> x = "A"*25
>>> x 
'AAAAAAAAAAAAAAAAAAAAAAAAA'
```

遗憾的是，Go中没有这么简便的构造器来构建任意长度的字符串。必须使用老风格的方式——使用循环——像下面这样的代码：

```go
var (
	n int
	s string 
)
for n = 0; n < 25; n++ { 
    s += "A"
}
```

显然，比Python有点冗长，但不难理解。

需要考虑的另一个问题是有效负载的传递机制。这依赖于目标程序或系统。在某些情况下，可能会涉及到向磁盘写入文件。另一些情况下，可能通过TCP/UDP与HTTP、SMTP、SNMP、FTP、Telnet或其他网络服务进行通信。

下面的例子中，将对远程FTP服务执行混淆测试。可以快速调整我们提供的许多逻辑来针对其他协议进行操作，因此它应该作为针对其他服务开发定制混淆器的良好基础。

虽然Go的标准包中包含对一些常见协议的支持，像HTTP和SMTP，但不支持客户端-服务器的FTP交互。可以使用支持FTP通信的第三方包代替，因此没必要从头开始写重复造轮子。然而，为了最大限度地控制（并欣赏该协议），使用原生的TCP通信来构建基础的FTP功能。如果需要回顾TCP是如何工作的，可以参考第2章。

#### 构建缓冲区溢出混淆器

清单9-1是混淆器的代码。（`/` 根路径下的所有代码清单都位于github 仓库 `https://github.com/blackhat-go/bhg/`。）硬编码了一些值，例如目标IP和端口，还有输入的最大长度。代码本身混淆了USER属性。由于此属性出现在用户身份验证之前，因此作为攻击面上的一个常见的可测试点。

```go
func main() {
	for i := 0; i < 2500; i++ {
		conn, err := net.Dial("tcp", "10.0.1.20:21") 
        if err != nil {
			log.Fatalf("[!] Error at offset %d: %s\n", i, err) 
        }
		bufio.NewReader(conn).ReadString('\n')
        
		user := ""
		for n := 0; n <= i; n++ {
			user += "A" 
        }
        
		raw := "USER %s\n" 
        fmt.Fprintf(conn, raw, user)
		bufio.NewReader(conn).ReadString('\n')

        raw = "PASS password\n" 
        fmt.Fprint(conn, raw) 
        bufio.NewReader(conn).ReadString('\n')

        if err := conn.Close(); err != nil { 
            log.Println("[!] Error at offset %d: %s\n", i, err)
		} 
    }
}


```

清单 9-1: 缓冲区溢出混淆器 （`/ch-9/ftp-fuzz/main.go`）

代码一开始就是一个大循环。每次程序循环时，会在所提供的用户名上添加另一个字符。这样就将发送长度在1到2500个字符之间的用户名。

循环中的每次迭代，都会和目标FTP服务建立TCP连接。每当和FTP服务交互时，无论是初始化连接或后续的命令，都将服务器的响应作为一行单独显式读取。如此一来，代码会在等待TCP响应时阻塞，也就不会在数据包返回前过早地发送命令。然后用另一个 `for` 循环用之前介绍的方式构建 `A` 的字符串。使用外部循环的索引 `i` 来构建基于当前循环迭代的字符串长度，这样程序每次重新开始时，字符串长度都会增加1。 通过使用 `fmt.Fprintf(conn, raw, user)` 将该值写入到 `USER` 命令中。

尽管可以在此时结束与FTP服务器的交互(毕竟，只混淆了 `USER` 命令)，但可以继续发送 `PASS` 命令来完成事务。最后，干净地关闭链接。

值得注意的有两点，其中，异常连接行为可能表明服务中断，这意味着潜在的缓冲区溢出：当第一次建立链接，然后链接关闭。如果在下次循环时不能建立链接，很可能出问题了。然后，检查服务是否由于缓冲区溢出而崩溃了。

如果建立链接后不能关闭，这可能是远程FTP服务突然断开的异常行为，但是，可能不是由于缓冲区溢出造成的。先记录下异常情况，程序继续执行。

图9-1是抓到的包，显示后续的每个 `USER` 命令的长度都在增加，确定代码按预期执行。

<div align=center><img width = '640' height ='488' src ="https://github.com/YYRise/black-hat-go/raw/dev/ch-9/images/9-1.jpg"/></div>

图9-1 Wireshark捕获到每次程序循环时 `USER` 命令增加一个字母

有几种方法能提高代码的灵活性和方便性。例如，可能的话移除IP，端口，迭代值的硬编码，而通过命令行参数或配置文件传入。可以作为练习。另外，扩展代码，以便在身份验证后混淆命令。特别地，更新工具来混淆 `CWD/CD` 命令。从历史上看，各种工具都容易受到与该命令的处理有关的缓冲区溢出的影响，这使其成为混淆测试的好目标。

### SQL注入混淆

本部分将探索SQL注入模糊测试。攻击的这种变化不是更改每次输入的长度，而是通过定义的输入列表循环以尝试SQL注入。换句话来说就是，通过尝试由各种SQL元字符和语法组成的输入列表来混淆网站登录表单的username参数，如果后端数据库对其进行不安全的处理，则会导致应用程序产生异常行为。

为简单起见，仅探测基于错误的SQL注入，忽略像boolean-, time-, 和 union-based等其他形式。这意味着，无需在响应内容或响应时间上寻找细微的差异，而在HTTP响应中查找错误消息以表明SQL注入。也意味着希望web服务保持运行状态，因此不能再依赖连接的建立来检验是否成功创建了异常行为。相反，需要在响应体中搜索数据库错误消息。

#### SQL注入原理

SQL注入的核心是，攻击者在语句中插入SQL元字符，从而有可能操纵查询以产生意外行为或返回受限的敏感数据。开发者盲目地将不受信任的用户数据连接到他们的SQL查询时，就会发生此问题，如以下伪代码所示：

```go
username = HTTP_GET["username"]
query = "SELECT * FROM users WHERE user = '" + username + "'" result = db.execute(query)
if(len(result) > 0) {
    return AuthenticationSuccess()
} else {
    return AuthenticationFailed()
}
```

伪代码中，变量username直接从HTTP参数中读取。该值未经过校验和验证。然后使用该值直接拼接到SQL查询语句中来构建查询字符串。程序查询数据库并检查结果。如果匹配到至少一条记录，则身份验证成功。只要提供的用户名由字母数字和某些特殊字符组成，该代码就应具有适当的行为。例如，提供用户名alice会是下面的安全查询：

```SQL
SELECT * FROM users WHERE user = 'alice'
```

但是，当用户名含单引号时会发生什么呢？提供用户名 `o'doyle` 会产生以下查询：

```SQL
SELECT * FROM users WHERE user = 'o'doyle'
```

这里的问题是后端数据库现在看到不平衡数量的单引号。注意前面查询的强调部分**`doyle`** ；后端数据库将其解释为SQL语法，因为它位于引号之外。当然，这是无效的SQL语法，并且后端数据库也不会处理。对于基于错误的SQL注入，会在HTTP响应中生成一个错误消息。消息本身将根据数据库而有所不同。MYSQL中会收到类型下面的的错误，可能还会包含其他详细信息，从而关闭查询本身：

```SQL
You have an error in your SQL syntax
```

尽管我们不会太深入地研究，但是现在可以操纵用户名输入来生成有效的SQL查询，该查询将绕过示例中的身份验证。输入 `' OR 1=1#`的用户名，恰好位于下面的SQL语句中：

```SQL
SELECT * FROM users WHERE user = '' OR 1=1#'
```

该输入在查询的末尾附加了逻辑 `OR`。该 `OR` 语句总是为真，因为1总是等于1。然后使用MySQL的注释（#）强制后端数据库忽略剩余的查询。这是有效的SQL语句。假设数据库中存在一行或多行数据，就可以绕过前面伪代码中的身份验证。